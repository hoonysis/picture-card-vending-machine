# 🤖 AI & 개발자를 위한 프로젝트 가이드 (그림카드 자판기)

## 0. ⭐ 사용자 필승 프롬프트 (Cheatsheet)
**[가장 위로 올림]** 매번 찾기 힘들어서 맨 위로 박제함.

### [Start] 작업 시작
> **"작업 시작. `AI_GUIDE.md`, `task.md` 읽고, `chat/` 폴더의 최근 요약본도 확인해서 브리핑해줘."**

### [Deploy] 배포 하고 싶을 때
> **"야, 이제 깃허브에 올려줘. (파일 목록 먼저 보여주고 승인해줄게)"**

**[배포 3단 콤보 절차]**
1. **AI**: "깃허브에 올렸습니다!" (보고)
2. **선생님**: 파이썬애니웨어 접속 ➡️ BASH 콘솔 클릭 ➡️ **`git pull`** 입력 ➡️ 엔터!
3. **선생님**: Web 탭 클릭 ➡️ Reload 클릭!

### [Debug] 뭔가 안 될 때 (New)
> **"아 뭔가 이상해. 뇌피셜 굴리지 말고 '진단 키트(/api/debug/status)'부터 찔러봐."**

### [End] 작업 종료
> **"작업 끝. 오늘 배운 레슨 `AI_GUIDE.md`에 업데이트하고, `chat/` 폴더에 요약본 저장하고, 임시 파일들(test, check) 싹 정리해줘."**

---

## 0. 이 문서의 유지보수 원칙 (Meta-Rules)
*   **Single Source of Truth**: 이 파일은 프로젝트의 **'일기장(History)'이 아니라 '헌법(Rules)'**입니다.
*   **No Logs**: 작업 내역이나 날짜별 히스토리는 절대 여기에 기록하지 마세요. (별도 `chat/` 폴더나 커밋 메시지 활용)
*   **갱신(Update) 중심**: 변경 사항이 생기면 로그처럼 밑에 추가하지 말고, **해당 항목의 내용을 수정**하여 항상 최신 상태를 유지하세요.
*   **참조 우선**: 작업을 시작하기 전 무조건 이 파일을 먼저 읽어, 프로젝트의 암묵적인 룰(Rule)을 파악해야 합니다.
*   **한글 사용 필수 (Korean Only)**: 계획 문서(Plan), 주석, 대화, 커밋 메시지 등 **모든 텍스트는 무조건 한글**로 작성합니다. (영어로 쓰면 혼납니다.)

---

## 1. 개발 철학 & 작업 수칙 (Philosophy & Protocol)

### 1.1. 바이브 코딩(Vibe Coding) 6대 개발 원칙
이 프로젝트의 코드 품질과 지속 가능성을 위해 다음 6가지 철학을 강제합니다.

1. **바퀴를 재발명하지 마라 (Don't Reinvent the Wheel)**
    * 복잡한 UI나 알고리즘 필요 시, 내가 직접 짜는 것보다 **검증된 라이브러리(CDN)**나 **오픈소스** 활용을 최우선으로 제안합니다.
    * 기존에 잘 작동하는 레거시 코드가 있다면, 무리하게 새로 짜지 말고 그 로직을 분석하여 재사용합니다.
2. **개념 탑재 우선 (Concept First)**
    * 새로운 라이브러리나 낯선 기술을 도입할 때는, 코드를 짜기 전에 **핵심 개념과 도입 이유**를 사용자에게 먼저 브리핑합니다. (무지성 코드 생성 금지)
3. **1,500줄의 법칙과 모듈화 (Strict Modularity)**
    * **Rule of 1500**: 모든 소스 파일은 1,500줄을 넘기지 않습니다.
    * **Action Plan**: 특히 비대해지기 쉬운 **`admin.html`** 내부의 스크립트가 길어지면, 지체 없이 **`js/` 폴더 내의 별도 파일(예: `admin_logic.js`)로 분리**를 제안해야 합니다.
    * **DRY (Don't Repeat Yourself)**: 같은 로직이 2번 이상 반복되면 즉시 함수로 추출합니다.
4. **교차 검증과 점진적 리팩토링 (Safety Verification)**
    * **백업은 이미 완벽하다**: `project_backup.py`를 믿되, **로직의 안전성**을 의심하십시오.
    * **설계 검증**: 대규모 로직 변경 시에는 바로 코딩하지 말고, *"이 로직에 엣지 케이스나 구멍이 없을까?"* 스스로 자문(Self-Correction)한 뒤 사용자에게 계획을 컨펌받습니다.
    * **점진적 적용**: 한 번에 모든 것을 바꾸려 하지 말고, 작동하는 상태를 유지하며 조금씩 개선합니다.
5. **명명 규칙의 구조화 (Structured Naming)**
    * `btn1`, `data`, `handler` 같은 모호한 이름은 **엄격히 금지**합니다.
    * **형식**: **`[도메인/위치]_[대상]_[동작/상태]`** (CamelCase 또는 snake_case 통일)
    * **예시**:
        * (X) `saveBtn` -> (O) `Admin_CardEditor_SaveBtn`
        * (X) `check()` -> (O) `Vending_Slot_CheckEmpty()`
6. **샌드박스 검증 전략 (Sandbox Strategy)**
    * 핵심 기능(메인 자판기 로직)을 수정할 때는 `admin.html`이나 `index.html`을 바로 건드리지 않습니다.
    * **`/test.html`** 또는 **별도 테스트 파일**을 생성하여 기능을 완벽히 검증한 후, 본체에 이식(Porting)하는 것을 원칙으로 합니다.
    * **승인 후 적용 (Explicit Approval)**: 샌드박스에서 테스트 중인 코드는 **사용자의 명시적 승인 전까지는 절대로 마스터 코드(`index.html` 등)에 자동 적용하지 않습니다.** (AI 독단적 판단 금지)

### 1.2. 개발자의 태도 (Pro Developer Mindset)
규칙은 아니지만, 우리가 지향해야 할 철학입니다.

1.  **YAGNI (You Aren't Gonna Need It)**
    *   "나중에 필요할지도 몰라"라며 미리 만들지 마세요. **지금 당장 필요한 것만** 만듭니다.
2.  **보이스카우트 규칙 (Boy Scout Rule)**
    *   "머물렀던 자리보다 더 깨끗하게." 코드를 수정하러 들어갔다면, 주변의 죽은 코드나 더러운 주석도 같이 정리하고 나오세요.
3.  **빨리 실패하기 (Fail Fast)**
    *   에러를 숨기지 마세요. 문제가 생기면 그 즉시 멈추고 로그를 뿜어야, 나중에 더 큰 재앙을 막을 수 있습니다.

### 1.3. AI 작업 시 유의사항 ("이것만은 꼭 지켜라")
1.  **"서버 코드는 신중하게"**: `server.py`는 배포가 번거로우므로(리로드 필요), 가능한 프론트엔드(`admin.html`, JS)에서 해결할 수 있는 문제는 프론트에서 해결한다. (예: 파일명 변경)
2.  **"배포 가이드(Git Flow)"**: 작업 완료 시, 사용자가 바로 배포할 수 있도록 **"커밋 메시지 제안"**과 **"이미지/데이터 변경 여부"**를 체크해준다. (데이터 변경 시엔 3단계 배포 스크립트 강조)
3.  **"경로 호환성"**: Windows(개발) <-> Linux(서버) 환경 차이를 항상 고려한다. `os.path.join`을 생활화한다.
4.  **"작업 마무리 원칙 (Session End)"**:
    *   개별 작업(Task)마다 백업/요약을 **하지 않는다**.
    *   사용자가 **"오늘 작업 끝낼게"**라고 할 때만 수행하되, **백업 스크립트 실행 후 완료를 기다리지 말고(No Wait) 즉시 "백업 시작했습니다"라고 보고하고 대화를 마친다.** (타임아웃 에러 방지)
    *   수행 항목:
        *   `AI_GUIDE.md` 업데이트.
        *   `chat/` 요약 저장.
    *   **단, 예외**: 리팩토링 전 안전 백업은 기존대로 수행한다.
5.  **"대화하자" 프로토콜 준수**: 
    *   사용자가 프롬프트 끝에 **"대화하자"**라고 붙이면, **절대 바로 코드를 작성하지 않는다.**
    *   먼저 **구현 계획, 설계 방향, 혹은 예상되는 문제점**을 텍스트로 상세히 설명하고, 사용자와 충분한 합의를 거친 후에 코딩을 시작한다. (선(先)토의 후(後)코딩 원칙)
6.  **"업데이트 패키징 규칙 (Deprecated)"**:
    *   ~~`_update` 폴더 생성 및 압축 과정은 **Git 도입으로 인해 폐지**되었습니다.~~
    *   모든 변경 사항은 Git Commit으로 관리합니다.

---

## 2. 인프라 & 배포 (New Git Cycle)

### 2.1. 배포 및 운영 환경 (Modernized)
**이 프로젝트는 'GitHub'를 허브로 사용하여, 코드(Code)와 데이터(Data)를 엄격히 분리하여 배포합니다.**

*   **서버 환경**: PythonAnywhere (Linux 기반 Flask 서버)
*   **서버 디렉토리**: `/home/hangruclass/picture-card-vending-machine` (구 `vending_machine` 폐기)
*   **저장소(Repo)**: `https://github.com/hoonysis/picture-card-vending-machine` (Private/Public)
*   **배포 워크플로우 (Zero-FileZilla)**:
    1.  **로컬(Local)**: VS Code에서 작업 완료.
    2.  **보고(Report)**: AI가 "이 파일들이 올라갑니다"라고 목록을 보여줌.
    3.  **승인(Approval)**: 사용자가 **"올려"**라고 승인하면 그때 **Git Push** 실행.
    4.  **서버(Server)**: PythonAnywhere 콘솔에서 배포 스크립트 실행.

### 2.2. 데이터 분리 원칙 (Separation of Concerns)
*   **Code (GitHub 관리 대상)**:
    *   `server.py`, `html`, `css`, `js`, `requirements.txt`
    *   **특징**: 언제든 삭제하고 다시 받아도 되는 "로직".
*   **Data (GitHub 절대 금지 / 각자 관리)**:
    *   `user_images/`, `user_audio/`, `captured_images/` (사용자 업로드)
    *   `01_ㅇ...`, `02_ㅂ...` 등 모든 **번호 붙은 그림 폴더**
    *   `범주/`, `예전/`, `백업/` (대용량 보관 폴더)
    *   `word.xlsx`, `reference_words.xlsx` (데이터베이스 원본 엑셀)
    *   `data.js` (엑셀 변환 데이터)
    *   `user_cards.json`, `cards.db` (설정 DB)
    *   `credentials.json` (보안 키)
    *   **특징**: 절대 유실되면 안 되는 "자산". 서버 배포 시 백업 폴더에서 복사해옴.

### 2.3. [필수] 서버 배포 명령어 (Deployment Script)
**"심플하게 가자"** (사용자 요청에 따라 백업 없이 코드만 업데이트합니다.)

```bash
# 1. 폴더 이동
cd picture-card-vending-machine

# 2. 코드 최신화 (덮어쓰기)
git pull

# 3. 완료
echo "배포 완료! Web 탭에서 Reload를 눌러주세요."
```

---

## 3. 핵심 아키텍처 & 데이터 흐름 (Core Architecture)

### 3.1. 유니크 파일명 전략 (Unique Filename Strategy)
*   **목표**: 서버 성능 저하 없이 **브라우저 캐시 문제(구버전 이미지 노출)**를 100% 해결.
*   **원리(Immutable Infrastructure)**:
    *   모든 파일 업로드 시 **`파일명_타임스탬프.webp`** 형태로 저장하여, URL을 유일하게 만듦.
    *   자판기는 항상 새로운 URL을 참조하므로, 무조건 최신 이미지를 로드함 (Speed & Freshness).
*   **운영 방식**:
    *   **관리자 페이지 (`admin.html`)**: 업로드 시 기존 파일(`이전버전`)은 **자동 삭제**하고, 새 파일(`새버전_시간`)을 업로드함.
    *   **나만의 그림 (`logic_upload.js`)**: 동일하게 시간 도장을 찍어 중복 방지.
*   **장점**:
    *   서버는 단순히 파일 저장만 수행 (I/O 부하 0%).
    *   사용자는 별도의 '캐시 초기화' 불필요.

### 3.2. 서버 동기화 및 데이터 관리 (Critical)
- **절대 원칙**: 서버는 데이터베이스(`word.xlsx`)의 **삭제 주체**가 되어서는 안 된다.
    - 파일이 누락되어 있어도 DB에서 자동으로 행을 삭제하는 로직(`auto-purge`)은 **금지**한다. (사용자가 실수로 이미지를 안 올렸을 때 데이터까지 날아가는 대참사 방지)
    - **클린 슬레이트(Clean Slate) 전략**:
    - 데이터가 심각하게 꼬였을 경우(예: 로컬 1500개 vs 서버 900개), **서버 데이터를 삭제하고 로컬 마스터 데이터로 덮어쓰는 것**이 가장 빠르고 정확하다.
    - 단, 로컬 데이터는 반드시 **모든 이미지 파일과 엑셀 파일이 정합성(경로 일치)을 가진 상태**여야 한다.
    - **유령 파일(Ghost File) 복구**:
        - 서버에 파일은 존재하나 DB(`word.xlsx`) 기록이 사라진 경우, **'자동 복구' 대신 '수동 재건'**을 원칙으로 한다.
        - 관리자 페이지 필터에 임시 카테고리를 추가하여 UI 상에서 직접 삭제/관리할 수 있게 돕는 것이 서버 자동화보다 안전하다.
        - **카테고리 구분자**: DB 상의 경로 구분자(`/` vs `·`) 차이로 인한 필터링 오류를 방지하기 위해, 검색 시 `normalize` 함수를 통해 특수문자를 제거하고 매칭한다.

### 3.3. 데이터 동기화 시스템 (Google Sheet Sync)
*   **스마트 동기화 (Smart Sync)**:
    *   **문제**: Google Sheet에 `단어 [발음]` 형태로 저장된 경우, 시스템이 `단어`로 검색하면 못 찾는 문제 발생.
    *   **해결**: `SyncManager`가 데이터를 읽을 때 **[ ] 괄호 뒷부분을 자동으로 제거**하고, 원본 키(`단어 [발음]`)와 정제된 키(`단어`)를 모두 매핑하여 조회 성공률을 100%로 높임.
*   **데이터 위생 (Data Hygiene)**:
    *   **저장 원칙**: `server.py`가 Google Sheet에 저장할 때, 무조건 **[발음] 접미사를 제거하고** 순수 `단어` 이름만 저장하도록 강제한다. (소스 오염 방지)
*   **성능(Latency)**: Google API 통신 특성상 **조회/저장에 2~3초 소요**되는 것은 정상 동작임. (로컬 엑셀 대비 느림)
*   **UI 정책**: '사전 업데이트' 버튼 등 사용 빈도가 낮거나 오해를 유발하는 UI는 **삭제하지 않고 숨김(display: none)** 처리하여 필요 시 복구 가능하도록 한다.

### 3.4. 스마트 게이트 (Smart Gate v2) & 글로벌 동기화
*   **파일**: `js/temp_gate.js` (프론트), `server.py` (`api/register_user`, `api/users`)
*   **하이브리드 명단 시스템 (Hybrid User List)**: 대문 입장 시 다음 3가지 소스를 병합(Merge)하여 보여준다.
    1.  **VIP 명단 (Static)**: 코드에 하드코딩된 주요 선생님 명단.
    2.  **서버 데이터 (Global)**: `/api/users`를 통해 실제 서버에 폴더가 존재하는 사용자 목록. (어디서든 동기화됨)
    3.  **로컬 캐시 (Local)**: `localStorage`에 저장된 최근 접속 기록.
*   **등록 메커니즘 (Server-First)**:
    *   사용자가 수동으로 이름을 입력하면 **즉시 `POST /api/register_user`를 호출**한다.
    *   서버는 `user_images/beta_HASH/` 폴더와 `.name` 파일을 생성한다.
    *   이후 해당 사용자는 전 세계 어느 PC에서 접속하든 버튼이 자동으로 노출된다.

---

## 4. 관리자 시스템 명세 (Admin Features)

### 4.1. 스마트 파일명 정리 (Smart Rename Interceptor)
*   **목표**: 파일명 뒤의 ` (N)` 패턴 제거 및 사용자 확인 후 업로드.
*   **UI 변경 (No-Popup)**: 기존 팝업창을 제거하고, 메인 화면 "최종 등록될 이름" 상단에 **인라인(Inline) 바** 형태로 통합.
*   **워크플로우 (One-Key Pass)**:
    1.  **드래그**: 파일 투척 시 즉시 **자동 분석** 시작.
    2.  **F4 클릭**: 분석 결과가 만족스러우면 **[모두 저장하기]** 즉시 실행. (팝업 확인 불필요)
    3.  **수정 시**: 인라인 입력칸 수정 -> **Enter** (재분석) -> **F4** (저장).
*   **중복 처리**: 중복 파일 발견 시 **팝업 없이** 서버에서 자동으로 `파일명_1.webp` 형태로 저장.
*   **주의**: **`server.py`는 파일명 변경 로직에 관여하지 않음.** (클라이언트 사이드 처리 원칙)

### 4.2. 릴레이 업로드 & 안전 장치
- **릴레이 업로드**: `admin.html`에서 여러 파일을 드래그하면, **Queue**에 쌓아두고 하나씩 순차적으로 처리한다.
- **F3 단축키**: [분석하기] 버튼을 실행한다. (발음 수정 후 바로 적용할 때 유용)
- **F4 단축키**: [모두 저장하기]를 실행하며, 팝업 확인 과정을 건너뛴다.
- **사용자 경험**: "중단" 버튼을 누르기 전까지 자동으로 다음 파일의 수정 모달을 띄운다.

### 4.3. 관리자 목록 및 수정 로직 개선
*   **목록 표시 (List View)**: 기존 '음소별 중복 표시' 방식을 버리고, **이미지 파일 기준 1개씩만 표시**하는 '단어 중심' 뷰로 변경했습니다. (깔끔해짐)
*   **수정 팝업 (Edit Modal)**:
    *   **수정 가능**: '언어 분류(대범주/소범주)'는 자유롭게 수정 가능하며, 저장 시 해당 이미지와 연결된 **모든 데이터가 일괄 업데이트** 됩니다.

### 4.4. 글로벌 입력 잠금 (Global Input Lock)
*   **배경**: 사용자의 중복 클릭(더블 클릭, 연타)이나 비동기 작업 중 단축키(`Delete`, `F2` 등) 사용으로 인한 **DB 꼬임 및 "Not Defined" 오류**를 원천 차단해야 한다.
*   **원칙**: "데이터를 건드리는 순간, 키보드와 마우스를 압수한다."
*   **구현**:
    *   `window.isGlobalProcessing` 플래그를 사용하여 모든 입력 핸들러(Keydown, Click)의 최상단에서 동작을 차단한다.
    *   **잠금 범위**: 로딩(`loadCards`), 저장(`uploadCard`), 분석(`analyzeName`), 삭제(`handleDelete*`) 등 모든 1초 이상 소요 작업.
    *   **안전 장치**: 잠금이 영원히 풀리지 않는(Deadlock) 상황을 방지하기 위해, 반드시 `try...finally` 블록의 `finally`에서 `false`로 해제하거나, 유효성 검사 실패 시 즉시 해제해야 한다.

---

## 5. 자판기 UX & 기능 명세 (Vending Machine Features)

### 5.1. UI 디자인 표준
*   **헤더(Header)**:
    *   **스타일**: 경계선(Border) 없는 **완전한 흰색**(Clean White) 배경.
    *   **저작권 배너**: 상단 경고 문구는 **제거**하여 깔끔함 유지.
*   **검색창(Search Bar)**:
    *   **스타일**: **쿠팡(Coupang)** 스타일 (파란색 `#4285f4` 직사각형 테두리, 우측 돋보기 아이콘).
    *   **크기**: 너비 **450px 고정** (Grid Layout의 자동 축소 방지).
*   **사용가이드 버튼**:
    *   **형태**: 텍스트 버튼 대신 **투명 배경 이미지(아이콘)** 사용.
    *   **워크플로우**: 이미지 업로드 -> `process_image.py`로 배경 제거 -> CSS에서 `background/border: none !important` 적용.
    *   **크기**: 헤더 높이에 맞춰 **55px 이상** 크게 배치.
*   **목록 카드(List Card)**:
    *   **썸네일**: 식별 편의를 위해 **높이 50px**의 이미지 썸네일을 포함한다.
    *   **기본 상태**: 목록 관리 섹션은 기본적으로 **'접힘(Collapsed)'** 상태를 유지하여 초기 로딩 체감 속도를 높이고 스크롤을 줄인다.
    *   **정보**: 음소 텍스트를 제거하고, [이미지+이름+(분류)]로 단순화하여 가독성을 높인다.
*   **로딩 피드백 (Spinner)**:
    *   모든 비동기 작업(분석, 저장, 로드)에 적용하되, **1초(1000ms) 이상** 소요될 때만 표시하여 시각적 피로도를 낮춘다. (Debounce 적용)

### 5.2. UI/UX 정밀 개선
*   **검색창 플레이스홀더**:
    *   현재 활성화된 탭(언어 vs 조음)에 따라 안내 문구를 동적으로 변경한다.
    *   예: "📚 언어 자판기에서 검색... (초성, 음절, 단어)"
*   **고충실도 인쇄 시스템 (High-Fidelity Print System)**:
    *   **화면 맞춤 (Zoom to Fit)**: 사용자의 화면 해상도에 맞춰 A4 미리보기가 **자동으로 축소(Scale Down)**되도록 기본 설정한다. (체크박스 불필요)
    *   **초기 옵션 (Defaults)**: '글자 표시', '테두리 표시'는 시인성을 위해 기본적으로 **켜짐(ON)** 상태를 유지한다.
    *   **장바구니 제한**: 쾌적한 렌더링을 위해 한 번에 **100장**까지만 담을 수 있도록 제한한다. (기존 200장에서 축소)

### 5.3. 자판기별 정렬 로직
*   **조음 자판기**: **위치 메타데이터(`sub`) 우선** > 가나다 순.
    *   **우선순위**: 1.어두초성 → 2.어중초성 → 3.어중종성 → 4.어말종성. (스펠링 분석 X, 꼬리표 신뢰 O)
    *   **이유**: '옷걸이(ㄷ)' vs '옷(ㅅ)' 처럼 소리와 철자가 다른 경우를 정확히 처리하기 위함.
*   **언어 자판기**: **클라이언트 강제 가나다 정렬**.
    *   서버의 가중치(조음 데이터 우선 등)를 철저히 무시하고, 브라우저단에서 이름순으로 재정렬하여 'ㅎ'이 'ㅇ'보다 먼저 나오는 문제를 방지함.

### 5.4. 바스켓(장바구니) 로직
- **100장 제한 (쾌적한 인쇄 환경)**: 렌더링 성능과 인쇄 안정성을 위해, **최대 100장**까지 담을 수 있도록 조정함. (초과 시 안내 메시지 출력)
- **프리셋 오류 방지 (Stability)**:
    - **Debounce**: 잦은 저장 요청 방지를 위해 최종 변경 1초 후 저장.
    - **Blocking Switch**: 프리셋 이동 시 화면 비활성화("저장 중..." Toast) 및 **강제 저장(Flush)** 후 이동하여 데이터 유실을 100% 방지한다.

### 5.5. 컨텍스트 메뉴 (Context Menu) - 캡처 & 복사 기능
*   **기능**: 카드 위에서 우클릭 시 "캡처 후 복사" 메뉴 제공.
*   **기술적 구현**:
    *   `html2canvas` 라이브러리를 사용하여 DOM 요소를 이미지로 변환.
    *   `Clipboard API` (`navigator.clipboard.write`)를 통해 클립보드로 이미지 전송.
*   **접근성**: 카드 우상단에 `...` (Three-dots) 버튼을 추가하여 모바일/비숙련자도 메뉴를 쉽게 찾을 수 있도록 개선. (Hover 시 등장)

### 5.6. 튜토리얼 가이드 (Driver.js) 운영 원칙
*   **Passive Mode (관람형 중심)**:
    *   사용자가 직접 클릭하게 유도하지 않는다. (오작동 및 피로도 방지)
    *   **"Glass Wall" & "Event Interceptor"**: 튜토리얼 중에는 `z-index: 999999999`의 투명 막과 `capture: true` 이벤트 리스너를 사용하여 **"다음" 버튼 외의 모든 클릭을 원천 봉쇄**한다.
    *   **Self-Driving**: 메뉴 열기, 카드 담기 등의 액션은 코드가 **자동으로 시뮬레이션(Simulated visual)**하여 보여준다.
*   **기술적 노하우 (Troubleshooting)**:
    *   **버튼 강제 주입**: Driver.js의 렌더링이 불안정할 경우, `onPopoverRendered`에서 직접 DOM(`document.createElement('button')`)을 주입하여 내비게이션을 보장한다.
    *   **화면 흔들림 방지**: `requestAnimationFrame` 루프를 통해 팝업의 위치(Position)를 1px 오차 없이 강제로 고정한다.
    *   **Highlight Refresh**: `display: none`인 요소를 강제로 보여줄 때는, 반드시 `tour.refresh()`를 호출하여 하이라이트 위치를 재계산시킨다.
    *   **종료 편의성**:
        *   **종료 버튼(X)**: Driver.js 기본 UI 대신, `driver-popover` 우상단에 직관적인 'X' 버튼을 강제로 주입하여 언제든 튜토리얼을 종료할 수 있게 한다.
        *   **초기화**: 튜토리얼 진입 시 장바구니(`basket-grid`)를 **자동으로 비워서** 하이라이트 위치 오류를 방지하고 깔끔한 시작을 보장한다.
    *   **사이드바 안내**: 인트로 직후 '왼쪽 메뉴'를 설명하는 단계를 추가하여 자판기 모드(언어/조음)의 차이를 설명한다.

---

## 6. 체험단 & 임시 모드 (Beta Features)

### 6.1. 체험단(Beta) 모드 관리 프로토콜
현재 "체험단 테스트"를 위해 임시 기능(입장 게이트, 격리 폴더)이 적용되어 있습니다.

**[Command] "체험단 종료해줘"**
이 명령을 내리면 AI는 다음 절차를 **순서대로** 수행해야 합니다:

1.  **Frontend 복구**:
    *   `index.html`에서 `<script src="js/temp_gate.js">` 라인 삭제.
    *   `js/temp_gate.js` 파일 삭제 (또는 `_backup`으로 이동).
2.  **Backend 복구 (`server.py`)**:
    *   `list_users` 엔드포인트 (`/api/users`) 삭제.
    *   `get_user_dir` 함수에서 `user_test` 관련 분기 로직 삭제 (순수 `user_images` 로직으로 복귀).
3.  **데이터 처리**:
    *   사용자에게 질문: *"user_test 폴더의 데이터를 user_images로 병합할까요, 아니면 보관(Archive)만 할까요?"*

---



## 8. ⚠️ 안정성 원칙 (Lessons Learned)
이 섹션은 시스템 안정성을 위해 반드시 지켜야 할 "금지 사항" 및 "원칙"을 기록합니다.

### 8.1. 릴레이 업로드 간섭 금지
*   **[금지]** 릴레이 업로드 중에 "건너뛰기", "중단" 버튼을 추가하지 마십시오. 비동기 상태 관리(Async State Management)가 꼬여 무한 로딩이나 데이터 누락을 유발합니다.
*   **[원칙]** 릴레이는 "한 번 시작하면 끝까지 간다"는 원자성(Atomicity)을 유지해야 합니다. 중단 기능이 필요하면, 큐(Queue) 전체를 비우고 초기화하는 방식(`resetUploadUI`)으로만 구현하십시오.

### 8.2. 데이터 로딩 무결성
*   **[원칙]** 관리자 UI 코드를 수정할 때는 반드시 `window.loadCards()` 호출 시점이 보장되는지 확인해야 합니다.
*   **[진단]** "서버에는 파일이 있는데 목록에 안 뜬다"는 리포트가 오면 클라이언트 필터링 문제가 아니라, **서버의 Data Load Exception**부터 의심하십시오. (Silent Failure 방지)

---
### 8.3. 크로스 플랫폼 및 배포 무결성 (Deployment Hygiene)
*   **[Deployment] 선(先)검증 후(後)배포**:
    *   **절대 원칙**: 로컬(`localhost`)에서 완벽하게 작동하는 것을 **사용자가 눈으로 확인하기 전까지는** 절대 GitHub에 Push하지 않습니다.
    *   **이유**: 로컬에서 안 되면 서버에서도 안 됩니다. "일단 서버에 올려서 테스트해볼까요?"는 금지어입니다.
*   **[Hangul] NFC 정규화 위생 (Normalization Hygiene)**:
    *   **원칙**: Mac/Linux/Windows 간 한글 자소 분리(NFD) 문제를 방지하기 위해, **입력(Input)과 저장(Storage) 모든 단계에서 `unicodedata.normalize('NFC', ...)`를 강제**합니다.
    *   **적용 대상**: `server.py`의 `load_reference_dict` (Key), `analyze_name` (Query), `sync_manager` (GSheet Data).
*   **[Excel] 인덱스 정합성 (Index Zero Rule)**:
    *   **문제**: `read_excel`은 헤더 유무에 따라 인덱스가 밀릴 수 있으며, `iloc[1]` 같은 하드코딩은 위험합니다.
    *   **해결**: `word.xlsx` 등 고정 템플릿을 읽을 때는 `header=0`을 명시하고, **0-based Index (`iloc[0]`)**를 기준으로 데이터를 읽어야 합니다. (1-based 가정 금지)

### 8.4. 서버 운영 및 데이터 마이그레이션 (Server Ops)
*   **[Config] Web Tab 경로 일치 (Path Match)**:
    *   `git clone`으로 **새 폴더**를 만들었다면, 반드시 **PythonAnywhere Web Tab**의 `Source code`와 `Working directory` 경로를 수정해야 합니다. (수정 안 하면 옛날 폴더가 실행됩니다.)
    *   **증상**: 코드(`check_*.py`)는 최신인데, 서버 로그(`Error Log`)는 옛날 에러를 뱉거나 `Coming Soon` 페이지가 뜸.
*   **[Migration] 코드와 데이터의 결합 (Code-Data Merge)**:
    *   **상황**: `git clone`으로 코드를 새로 받으면, `.gitignore` 때문에 `user_images`나 `word.xlsx` 같은 **데이터 파일이 없는 상태**가 됩니다.
    *   **해결**: 서버 내부에서 **구 폴더의 데이터 -> 신 폴더로 복사(`cp -r`)**하는 과정이 필수입니다.
    *   **주의**: `cp -r old/* new/` 명령 사용 시 코드가 덮어씌워질 수 있으므로, 복사 후 반드시 **`git reset --hard origin/main`**으로 코드를 최신화(원복)해야 합니다.
*   **[Diag] 진단 키트 활용 (`/api/debug/status`)**:
    *   서버가 "파일 없음" 에러를 숨기거나 이상 동작을 할 경우, 로그를 뒤지는 것보다 **진단 엔드포인트**를 호출하여 내부 상태(파일 존재 여부, 캐시 크기, Last Error)를 확인하는 것이 훨씬 빠릅니다.

---
*Refactored: 2026-02-03 (배포 프로토콜 단순화 & 서버 마이그레이션 수칙 추가)*
